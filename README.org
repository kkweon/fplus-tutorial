#+PROPERTY: header-args :flags -std=c++1z :exports both :results output
#+TITLE: Functional Programming in C++ w/ FPLUS

* Introduction
All of stuff come from
- [[https:www.udemy.com/functional-programming-using-cpp][Udemy Functional Programming C++]]
- [[https:github.com/Dobiasd/FunctionalPlus][Functional Plus]] 
  
** Installation
- Go to https://github.com/Dobiasd/FunctionalPlus
- Follow the instruction
** Check installation
#+BEGIN_SRC C++ :flags -std=c++1z :exports both
  #include <fplus/fplus.hpp>
  #include <iostream>

  int main() {
    std::list<std::string> things = {"same old", "same old"};
    if (fplus::all_the_same(things))
      std::cout << "All things being equal." << std::endl;
  }
#+END_SRC

#+RESULTS:
: All things being equal.


#+BEGIN_SRC C++ :flags -std=c++1z :exports both
  #include <fplus/fplus.hpp>
  #include <iostream>

  int main() {
    std::string team = "Our team is great. I love everybody I work with.";
    std::cout << "There actually are this many 'I's in team: "
              << fplus::count("I", fplus::split_words(false, team)) << std::endl;
  }
#+END_SRC

#+RESULTS:
: There actually are this many 'I's in team: 2


* Correctness follows from expressive 

- Define a =map= function ((a -> a), [a]) -> [a]
- Define a =keep_if= function ((a -> Bool), [a]) -> [a]
#+BEGIN_SRC C++ :exports both :results output
  #include <algorithm>
  #include <fplus/fplus.hpp>
  #include <iostream>
  #include <vector>

  using namespace std;

  struct square {
    template <typename T> T operator()(T val) { return val * val; }
  };

  template<typename T>
  T square_fn(T val) {
    return val * val;
  }

  template <typename Function, typename T>
  vector<T> my_transform(Function f, const vector<T> &containers) {
    vector<T> ret;
    transform(begin(containers), end(containers), back_inserter(ret), f);
    return ret;
  }

  template <typename Container> void print_vec(const Container &container) {
    cout << "[";
    int i = 0;
    for (auto &val : container) {
      if (i == container.size() - 1) {
        cout << val;
      } else {
        cout << val << ", ";
      }
      i++;
    }
    cout << "]\n";
  }

  template<typename Function, typename T>
  vector<T> keep_if(Function f, const vector<T>& container) {
    vector<T> ret;
    ret.reserve(container.size());
    std::copy_if(begin(container), end(container), back_inserter(ret), f);
    return ret;
  }


  int main() {
    vector<int> result{1, 2, 3, 4, 5, 6, 7, 8, 9};
    print_vec(result);

    /// my transform function
    auto squared = my_transform(square_fn<int>, result);
    print_vec(squared);

    /// fplus function
    auto fplus_squared = fplus::transform(square_fn<int>, result);
    print_vec(fplus_squared);

    auto is_even = [](auto val) {
      return val % 2 == 0;
    };

    /// my_keep_if function
    print_vec(keep_if(is_even, squared));
    
    /// fplus_keep_if function
    print_vec(fplus::keep_if(is_even, squared));

    return 0;
  }
#+END_SRC

#+RESULTS:
: [1, 2, 3, 4, 5, 6, 7, 8, 9]
: [1, 4, 9, 16, 25, 36, 49, 64, 81]
: [1, 4, 9, 16, 25, 36, 49, 64, 81]
: [4, 16, 36, 64]
: [4, 16, 36, 64]


* Type annotations
Type annotations are used to browse the [[http://www.editgym.com/fplus-api-search/][FunctionalPlus API Search]].

- Type variables are written in lower case such as ~a~, ~b~, ...
- Fixed types starts with a Uppercase letter such as ~Int~, ~String~, ~Bool~

** Variables
Variables can be expressed in the following way
#+BEGIN_SRC C++
int x;              // x : Int
vector<int> xs;     // xs: [Int]
pair<int, float> p; // p : (Int, Float)
#+END_SRC

** map
In C++, ~map~ is like an ~dict~ in Python

#+BEGIN_SRC C++
map<string, int> dict; // dict : Map String Int
#+END_SRC

** Function

#+BEGIN_SRC C++
int foo(string value);                              // foo : String -> Int
ContainerIn transform(F f, const ContainerOut& xs); // transform : ((a -> b), [a]) -> [b]
#+END_SRC


Previous ~keep_if~ can be written as 
#+BEGIN_SRC C++
Container keep_if(F f, Container& container); // keep_if : ((a -> Bool), [a]) -> [a]
#+END_SRC

** Why useful?
Suppose I want a ~concat~ function as below.
#+BEGIN_SRC C++ :exports both
concat(["Bar", "Baz", "Buz"], ";") == "bar;baz;buz"
#+END_SRC

We know 

#+BEGIN_SRC C++ :exports both
concat(vector<string> container, string delim); // 
#+END_SRC

If we type the following annotation in the API browser,
=(vector<string>, string)->string=


we get

#+BEGIN_EXAMPLE
(vector<string>,string)->string
as parsed type: ([String], String) -> String
---------------------------------------------------------
join : ([a], [[a]]) -> [a]
fwd::join : [a] -> [[a]] -> [a]
Inserts a separator sequence in between the elements
of a sequence of sequences and concatenates the result.
Also known as intercalate.
join(", ", "["a", "bee", "cee"]) == "a, bee, cee"
join([0, 0], [[1], [2], [3, 4]]) == [1, 0, 0, 2, 0, 0, 3, 4]

template <typename Container,
    typename X = typename Container::value_type>
X join(const X& separator, const Container& xs)
#+END_EXAMPLE
